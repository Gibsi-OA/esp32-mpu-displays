#include <SPI.h>
#include <SD.h>
#include <MPU9250_WE.h>
#include <WiFi.h>
#include <esp_now.h>
#include <esp_timer.h>
#include "MadgwickAHRS.h"
#include <TinyGPS++.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include <LCDi2c.h>

// ================= SETTINGS =================
#define SAMPLE_RATE_HZ      4000
#define ESPNOW_RATE_HZ      250
#define MAX_FILE_SIZE       75000000 // 75MB before rolling SD file
#define GPS_BAUD            9600
#define BUFFER_SIZE         512
#define SD_WRITE_BATCH      16
#define HSPI_MISO           26
#define HSPI_MOSI           27
#define HSPI_SCLK           25
#define HSPI_CS             14
#define SD_CS_PIN           5
#define RXD2                16
#define TXD2                17
#define LCD_ROWS            2
#define LCD_COLUMNS         16
#define LEDPIN              15

uint8_t rx_peer_mac[] = {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF}; 

// ================= OBJECTS & DATA =================
SPIClass hspi(HSPI);
SPIClass sdSPI(VSPI);
MPU9250_WE mpu(&hspi, HSPI_CS, true);
Madgwick filter;
File dataFile;
File logFile;
TinyGPSPlus gps;
HardwareSerial gpsSerial(2);
LCDi2c lcd(0x27, Wire);

bool REC = false, GPSValid = false, SDValid = false, firstSDfail = true, SDFULL = false;
float MaxX, MaxY, MaxZ;
int sessionID = 0;
int partCounter = 0;
unsigned long lastSuccessfulWrite = 0;
uint32_t totalSpace;
uint32_t usedSpace;
char path[32];


struct gpsData {
    double lat; double lng;
    float speed_kmph; float alt_meters;
    uint32_t satellites; uint32_t hdop_value;
    float heading_deg; uint32_t date_value; uint32_t time_value;
};
gpsData currentGpsData = {0};
portMUX_TYPE gpsDataMux = portMUX_INITIALIZER_UNLOCKED; 
portMUX_TYPE ringBufferMux = portMUX_INITIALIZER_UNLOCKED;

// ================= DATA STRUCTURES =================
struct __attribute__((packed)) TimeSyncPacket {
    int64_t unix_us;
};

struct __attribute__((packed)) dataTx {
    int64_t esp_elapsed_us;
    int64_t pc_us;         
    uint32_t utc_date;
    uint32_t utc_time;
    float acc[3];
    float gyro[3];
    float mag[3];       // Sent via ESP-NOW, not logged to SD
    float temp;
    float roll, pitch, yaw;  // Yaw sent via ESP-NOW, not logged to SD
    double lat; double lng;
    float speed_kmph;
    float alt_meters;   // Sent via ESP-NOW, not logged to SD
    uint32_t satellites;
    uint32_t hdop_value;  // Sent via ESP-NOW, not logged to SD
    float heading_deg;
    bool REC;
    char filename[14];
};

volatile dataTx ring[BUFFER_SIZE];
volatile uint16_t writeIndex = 0;
volatile uint16_t sdReadIndex = 0;
volatile uint16_t espNowReadIndex = 0;
char csvBuffer[SD_WRITE_BATCH*300];

// ================= TIME HANDLING =================
int64_t pc_start_us = 0;
int64_t esp_start_us = 0;
int64_t first_pc_stamp = 0;
volatile bool first_sample = true;




// ================= LOGGING =================
void logEvent(const char* msg) {
    if (!SD.cardType()) return;

    if (!logFile) {
        logFile = SD.open("/log.txt", FILE_APPEND);
        if (!logFile) return;
    }

    logFile.printf("[%lld us] %s\n", esp_timer_get_time(), msg);
    logFile.flush();
}


// ================= SD ROLLING LOGIC =================

void openNewSDFile() {
    if (dataFile) dataFile.close();

    path[0] = '\0';
    snprintf(path, sizeof(path), "/data_%04d-%d.csv", sessionID, partCounter);

    dataFile = SD.open(path, FILE_WRITE);
    if (dataFile) {
        dataFile.println(
            "ESP_us,PC_us,Date,Time,AccX,AccY,AccZ,"
            "GyrX,GyrY,GyrZ,Temp,Roll,Pitch,"
            "Lat,Lng,Spd,Sats,Head"
        );
        dataFile.flush();
        char msg[64];
        snprintf(msg, sizeof(msg), "Opened file: %s", path);
        logEvent(msg);

        partCounter++;
        SDValid = true;
        lastSuccessfulWrite = millis();
    } else {
        SDValid = false;
        logEvent("Failed to open data file");
        Serial.println("Failed to open SD file!");
    }
}



//get initial file name
int findNextSessionID() {
    int maxSession = 0;

    File root = SD.open("/");
    if (!root) return 1;

    File file = root.openNextFile();
    while (file) {
        const char* name = file.name();

        // Match: /data_XXXX-Y.csv
        int s, p;
        if (sscanf(name, "data_%4d-%d.csv", &s, &p) == 2) {
            if (s > maxSession) {
                maxSession = s;
            }
        }

        file.close();
        file = root.openNextFile();
    }

    root.close();
    return maxSession + 1;
}


// ================= CALLBACKS & ISR =================

void OnTimeSyncRecv(const esp_now_recv_info_t * info, const uint8_t *incomingData, int len) {
    if (len != sizeof(TimeSyncPacket)) return;
    TimeSyncPacket receivedSync;
    memcpy(&receivedSync, incomingData, sizeof(TimeSyncPacket));
    pc_start_us = receivedSync.unix_us;
    first_pc_stamp = esp_timer_get_time();
    Serial.printf("PC time synced: %lld\n", pc_start_us);
    char msg[64];
    snprintf(msg, sizeof(msg), "PC time synced: %lld", pc_start_us);
    logEvent(msg);
    
}

void IRAM_ATTR samplingCallback(void* arg) {
    int idx = writeIndex;
    int64_t current_esp_time = esp_timer_get_time();

    if (first_sample) {
        esp_start_us = current_esp_time;
        first_sample = false;
    }

    ring[idx].esp_elapsed_us = current_esp_time - esp_start_us;
    ring[idx].pc_us = (first_pc_stamp) ? (current_esp_time - first_pc_stamp + pc_start_us) : 0;
    
    portENTER_CRITICAL_ISR(&gpsDataMux);
    ring[idx].utc_date = currentGpsData.date_value;
    ring[idx].utc_time = currentGpsData.time_value;
    ring[idx].lat = currentGpsData.lat;
    ring[idx].lng = currentGpsData.lng;
    ring[idx].speed_kmph = currentGpsData.speed_kmph;
    ring[idx].alt_meters = currentGpsData.alt_meters;
    ring[idx].satellites = currentGpsData.satellites;
    ring[idx].hdop_value = currentGpsData.hdop_value;
    ring[idx].heading_deg = currentGpsData.heading_deg;
    portEXIT_CRITICAL_ISR(&gpsDataMux);

    xyzFloat acc = mpu.getGValues();
    xyzFloat gyr = mpu.getGyrValues();
    xyzFloat mag = mpu.getMagValues();
    ring[idx].temp = mpu.getTemperature();

    if(acc.x > MaxX) MaxX = acc.x;
    if(acc.y > MaxY) MaxY = acc.y;
    if(acc.z > MaxZ) MaxZ = acc.z;
    
    ring[idx].acc[0]=acc.x; ring[idx].acc[1]=acc.y; ring[idx].acc[2]=acc.z;
    ring[idx].gyro[0]=gyr.x; ring[idx].gyro[1]=gyr.y; ring[idx].gyro[2]=gyr.z;
    ring[idx].mag[0]=mag.x; ring[idx].mag[1]=mag.y; ring[idx].mag[2]=mag.z;

    filter.update(gyr.x*DEG_TO_RAD, gyr.y*DEG_TO_RAD, gyr.z*DEG_TO_RAD, acc.x, acc.y, acc.z, mag.x, mag.y, mag.z);
    ring[idx].roll = filter.getRoll();
    ring[idx].pitch = filter.getPitch();
    ring[idx].yaw = filter.getYaw();

    ring[idx].REC = REC;
    strncpy(
    (char*)ring[idx].filename,path,sizeof(ring[idx].filename));
    ring[idx].filename[sizeof(ring[idx].filename) - 1] = '\0';

    writeIndex = (writeIndex+1) % BUFFER_SIZE;
}

// ================= TASKS =================

void gpsTask(void* parameter) {
    dataTx s;

    for (;;) {
        // 1. Process GPS
        while(gpsSerial.available() > 0){
            if(gps.encode(gpsSerial.read())){
                if(gps.location.isUpdated()){
                    portENTER_CRITICAL(&gpsDataMux);
                    currentGpsData.lat = gps.location.lat();
                    currentGpsData.lng = gps.location.lng();
                    currentGpsData.speed_kmph = gps.speed.kmph();
                    currentGpsData.alt_meters = gps.altitude.meters();
                    currentGpsData.satellites = gps.satellites.value();
                    currentGpsData.hdop_value = gps.hdop.value();
                    currentGpsData.heading_deg = gps.course.deg();
                    currentGpsData.date_value = gps.date.value();
                    currentGpsData.time_value = gps.time.value();
                    portEXIT_CRITICAL(&gpsDataMux);
                }
            }
        }
        if(gps.hdop.value()<10)
          GPSValid = true;
        else
          GPSValid = false;
        
        // 2. Fetch latest data from Ring Buffer
        uint16_t currentSampleIndex = (writeIndex + BUFFER_SIZE - 1) % BUFFER_SIZE;
        taskENTER_CRITICAL(&ringBufferMux);
        memcpy(&s, (const void*)&ring[currentSampleIndex], sizeof(dataTx));
        taskEXIT_CRITICAL(&ringBufferMux);

        // 3. LCD Update
        if(SDValid && !SDFULL)
        {
          lcd.printf("X%.1f Y%.1f Z%.1f  ", MaxX, MaxY, MaxZ); 
          lcd.locate(2,1);
          lcd.printf("R%dG%d X%d Y%d Z%d   ", 
              REC, 
              GPSValid, 
              (int)abs(s.acc[0]), 
              (int)abs(s.acc[1]), 
              (int)abs(s.acc[2])
          );
          lcd.home();
          digitalWrite(LEDPIN,LOW);
        }
        else
        {
          if(!SDFULL)
          {
            digitalWrite(LEDPIN,HIGH);
            if(firstSDfail)
            {
              REC=false;
              firstSDfail = false;
            }
          }
        }
        
        vTaskDelay(pdMS_TO_TICKS(200)); 
    }
}

void writeBatchToSD() {
  if(!SDFULL)
  {
        // Check if SD card is still present/working
        if(!dataFile || SDFULL) {
            openNewSDFile(); 
            if(!dataFile) {
                REC = false;
                SDValid = false;
                return;
            }
        }
    
        // Periodic SD card health check (every 5 seconds)
        static unsigned long lastHealthCheck = 0;
        if (millis() - lastHealthCheck > 5000) {
            lastHealthCheck = millis();
        
            // Check SD still mounted
            if (!SD.cardType()) {
                Serial.println("SD card removed!");
                if (dataFile) dataFile.close();
                dataFile = File();
                SDValid = false;
                REC = false;
                digitalWrite(LEDPIN, HIGH);
                return;
            }
        
            // Check free space
            uint64_t totalSpace = SD.totalBytes();
            uint64_t usedSpace  = SD.usedBytes();
        
            if (totalSpace - usedSpace < 10ULL * 1024 * 1024) {
                Serial.println("SD FULL!");
        
                SDValid = false;
                REC = false;
                SDFULL = true;
                
                digitalWrite(LEDPIN, HIGH);
                logEvent("SD FULL CAN'T CONTINUE");
                
        
                if (dataFile) dataFile.close();
                dataFile = File();
                return;
            }
            logEvent("Health check passed");
        }
    
        if (dataFile.size() > MAX_FILE_SIZE) {
            openNewSDFile();
        }
    
        uint16_t localRead = sdReadIndex;
        uint16_t localWrite = writeIndex;
        char* ptr = csvBuffer;
        int lenTotal = 0;
        int batchCount = 0;
    
        while(localRead != localWrite && batchCount < SD_WRITE_BATCH) {
            dataTx s;
            taskENTER_CRITICAL(&ringBufferMux);
            memcpy(&s, (const void*)&ring[localRead], sizeof(dataTx));
            taskEXIT_CRITICAL(&ringBufferMux);
    
            // Filtered Output: No Mag, Yaw, Alt, HDOP
            int len = snprintf(ptr, sizeof(csvBuffer)-lenTotal,
                "%lld,%lld,%u,%u,%.2f,%.2f,%.2f,%.2f,%.2f,%.2f,%.2f,%.2f,%.2f,%.6f,%.6f,%.2f,%u,%.2f\n",
                s.esp_elapsed_us, s.pc_us, s.utc_date, s.utc_time,
                s.acc[0], s.acc[1], s.acc[2],
                s.gyro[0], s.gyro[1], s.gyro[2],
                s.temp, s.roll, s.pitch,
                s.lat, s.lng, s.speed_kmph, s.satellites, s.heading_deg);
    
            if(len <= 0 || lenTotal + len >= sizeof(csvBuffer)) break;
            ptr += len;
            lenTotal += len;
            localRead = (localRead + 1) % BUFFER_SIZE;
            batchCount++;
        }
    
        if(lenTotal > 0){
            size_t bytesWritten = dataFile.write((const uint8_t*)csvBuffer, lenTotal);
            
            // Check if write was successful
            if(bytesWritten != lenTotal) {
                Serial.println("SD write failed!");
                SDValid = false;
                REC = false;
                if(dataFile) dataFile.close();
                dataFile = File();
                return;
            }
            
            // Flush less frequently to improve performance
            static int flushCounter = 0;
            if(++flushCounter >= 10) {
                dataFile.flush();
                flushCounter = 0;
            }
            
            sdReadIndex = localRead;
            lastSuccessfulWrite = millis();
            REC = true;
            SDValid = true;
        } else {
            // Nothing to write, but SD is still working
            REC = false;
        }
        
        // If we haven't written successfully in 10 seconds, something might be wrong
        if(millis() - lastSuccessfulWrite > 10000) {
            Serial.println("No successful writes in 10 seconds - checking SD...");
            if(dataFile) dataFile.close();
            dataFile = File();
            openNewSDFile();
        }
    }
}

void sdWriteTask(void* parameter) {
    for (;;) {
        writeBatchToSD();
        vTaskDelay(pdMS_TO_TICKS(50)); // Write every 50ms
    }
}

void setup(){
    Serial.begin(115200);
    pinMode(LEDPIN, OUTPUT);
    

    // 2. Hardware
    lcd.begin(LCD_ROWS, LCD_COLUMNS);
    hspi.begin(HSPI_SCLK, HSPI_MISO, HSPI_MOSI, HSPI_CS);
    if(mpu.init()) {
        mpu.initMagnetometer();
        mpu.setGyrRange(MPU9250_GYRO_RANGE_2000);
        mpu.setAccRange(MPU9250_ACC_RANGE_16G);
        mpu.autoOffsets();
    }

    //initiats the SD and creates new file
    sdSPI.begin();
    if (SD.begin(SD_CS_PIN, sdSPI)) {
        sessionID = findNextSessionID();
        partCounter = 0;
        openNewSDFile();
        logFile = SD.open("/log.txt", FILE_APPEND);
        if (logFile) {
            logFile.println();
            logFile.println("=== BOOT ===");
            logFile.printf("SESSION: data_%04d\n", sessionID);
            logFile.flush();
        }

    }
    

    gpsSerial.begin(GPS_BAUD, SERIAL_8N1, RXD2, TXD2);
    
    // 3. Create FreeRTOS Tasks
    xTaskCreatePinnedToCore(gpsTask, "Gps", 4096, NULL, 1, NULL, 1); 
    xTaskCreatePinnedToCore(sdWriteTask, "SDWrite", 4096, NULL, 1, NULL, 1);

    // 4. WiFi & ESP-NOW
    WiFi.mode(WIFI_STA);
    esp_now_init();
    esp_now_register_recv_cb(OnTimeSyncRecv);
    
    esp_now_peer_info_t peerInfo={};
    memcpy(peerInfo.peer_addr, rx_peer_mac, 6);
    peerInfo.channel = 1;
    esp_now_add_peer(&peerInfo);

    // 5. Start Sampling Timer
    const esp_timer_create_args_t timer_args={ .callback=&samplingCallback, .name="sampling" };
    esp_timer_handle_t timer;
    esp_timer_create(&timer_args, &timer);
    esp_timer_start_periodic(timer, 1000000/SAMPLE_RATE_HZ); 
}

void loop(){
    static unsigned long lastSend = 0;
    if(millis() - lastSend >= 1000/ESPNOW_RATE_HZ){
        lastSend = millis();
        
        // Send latest sample via ESP-NOW
        uint16_t currentSampleIndex = (writeIndex + BUFFER_SIZE - 1) % BUFFER_SIZE;
        dataTx s;
        taskENTER_CRITICAL(&ringBufferMux);
        memcpy(&s, (const void*)&ring[currentSampleIndex], sizeof(dataTx));
        taskEXIT_CRITICAL(&ringBufferMux);
        
        esp_now_send(rx_peer_mac, (uint8_t*)&s, sizeof(s));
    }
    delay(1);
}