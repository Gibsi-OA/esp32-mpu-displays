import numpy as np
import serial
import math
import threading
from vispy import scene, io, app
from vispy.visuals.transforms import MatrixTransform
from ahrs.filters import Madgwick

# -----------------------------
# Serial setup
SERIAL_PORT = "/dev/ttyUSB0"
BAUD_RATE = 115200
ser = serial.Serial(SERIAL_PORT, BAUD_RATE, timeout=0.1)

latest_data = None
data_lock = threading.Lock()

# -----------------------------
# Gyro bias calibration
GYRO_BIAS_SAMPLES = 200
gyro_buffer = []

def serial_thread():
    global latest_data, gyro_buffer
    while True:
        try:
            line = ser.readline().decode('utf-8').strip()
            if not line or not line.startswith("t="):
                continue
            parts = line.split()
            ax, ay, az = float(parts[1]), float(parts[2]), float(parts[3])
            gx, gy, gz = float(parts[4]), float(parts[5]), float(parts[6])

            # Collect for bias estimation
            if len(gyro_buffer) < GYRO_BIAS_SAMPLES:
                gyro_buffer.append([gx, gy, gz])
            gyro_bias = np.mean(gyro_buffer, axis=0) if gyro_buffer else np.array([0.0,0.0,0.0])

            # Subtract bias
            gx -= gyro_bias[0]
            gy -= gyro_bias[1]
            gz -= gyro_bias[2]

            with data_lock:
                latest_data = (np.array([gx, gy, gz]), np.array([ax, ay, az]))
        except:
            continue

threading.Thread(target=serial_thread, daemon=True).start()

# -----------------------------
# VisPy setup
canvas = scene.SceneCanvas(keys='interactive', show=True, bgcolor='white')
view = canvas.central_widget.add_view()
view.camera = 'turntable'

mesh_data = io.read_mesh('plane.obj')
vertices, faces = mesh_data[0], mesh_data[1]
plane_mesh = scene.visuals.Mesh(vertices=vertices, faces=faces,
                                color=(0.2,0.5,1,0.8), parent=view.scene)
transform = MatrixTransform()
plane_mesh.transform = transform

# -----------------------------
# Madgwick filter
madgwick = Madgwick(frequency=60.0, beta=0.1)
q = np.array([1.0,0.0,0.0,0.0])
SMOOTH_ALPHA = 0.3
roll_smooth = pitch_smooth = yaw_smooth = 0.0

# -----------------------------
def update_plane(event):
    global q, roll_smooth, pitch_smooth, yaw_smooth, latest_data
    with data_lock:
        data = latest_data
    if data is None:
        return
    gyro, acc = data
    gyro_rad = np.deg2rad(gyro)
    acc_norm = acc / np.linalg.norm(acc)

    # Use fixed dt for consistency
    q = madgwick.updateIMU(q, gyr=gyro_rad, acc=acc_norm)

    q0, q1, q2, q3 = q
    roll = math.atan2(2*(q0*q1 + q2*q3), 1 - 2*(q1*q1 + q2*q2))
    pitch = math.asin(np.clip(2*(q0*q2 - q3*q1), -1.0, 1.0))
    yaw = math.atan2(2*(q0*q3 + q1*q2), 1 - 2*(q2*q2 + q3*q3))

    # Low-pass smoothing
    roll_smooth = SMOOTH_ALPHA * roll_smooth + (1-SMOOTH_ALPHA) * roll
    pitch_smooth = SMOOTH_ALPHA * pitch_smooth + (1-SMOOTH_ALPHA) * pitch
    yaw_smooth = SMOOTH_ALPHA * yaw_smooth + (1-SMOOTH_ALPHA) * yaw

    # Rotation matrix
    cr, sr = math.cos(roll_smooth), math.sin(roll_smooth)
    cp, sp = math.cos(pitch_smooth), math.sin(pitch_smooth)
    cy, sy = math.cos(yaw_smooth), math.sin(yaw_smooth)

    R = np.array([
        [cy*cp, cy*sp*sr - sy*cr, cy*sp*cr + sy*sr],
        [sy*cp, sy*sp*sr + cy*cr, sy*sp*cr - cy*sr],
        [-sp,   cp*sr,            cp*cr]
    ])
    M = np.eye(4)
    M[:3,:3] = R
    transform.matrix = M

# -----------------------------
timer = app.Timer(1/60, connect=update_plane, start=True)
app.run()
