#include <SPI.h>
#include <SD.h>
#include <MPU9250_WE.h>
#include <WiFi.h>
#include <esp_now.h>
#include <esp_timer.h>
#include "MadgwickAHRS.h"
#include <TinyGPS++.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include <LCDi2c.h>

// ================= SETTINGS =================
#define SAMPLE_RATE_HZ      4000
#define ESPNOW_RATE_HZ      250
#define GPS_BAUD            9600
#define BUFFER_SIZE         512
#define SD_WRITE_BATCH      16
#define HSPI_MISO           26
#define HSPI_MOSI           27
#define HSPI_SCLK           25
#define HSPI_CS             14
#define SD_CS_PIN           5
#define RXD2                16
#define TXD2                17
#define LCD_ROWS            2
#define LCD_COLUMNS         16

// MAC address of the receiver (0xFF,0xFF,0xFF,0xFF,0xFF,0xFF is broadcast)
uint8_t rx_peer_mac[] = {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF}; 

// ================= OBJECTS & DATA =================
SPIClass hspi(HSPI);
SPIClass sdSPI(VSPI);
MPU9250_WE mpu(&hspi, HSPI_CS, true);
Madgwick filter;
File dataFile;
TinyGPSPlus gps;
HardwareSerial gpsSerial(2);
LCDi2c lcd(0x27, Wire);
bool REC = false,GPSValid = false, Telmet = false;
int filesize;
float MaxX,MaxY,MaxZ;

struct gpsData {
    double lat;
    double lng;
    float speed_kmph;
    float alt_meters;
    uint32_t satellites;
    uint32_t hdop_value;
    float heading_deg;
    uint32_t date_value;
    uint32_t time_value;
};
gpsData currentGpsData = {0,0,0,0,0,0,0,0,0};
// Mutex to protect currentGpsData from race conditions (GPS task vs. Timer ISR)
portMUX_TYPE gpsDataMux = portMUX_INITIALIZER_UNLOCKED; 
// FIX: Mutex to protect the ring buffer access from FreeRTOS tasks
portMUX_TYPE ringBufferMux = portMUX_INITIALIZER_UNLOCKED;


// ================= DATA STRUCTURES =================
struct __attribute__((packed)) TimeSyncPacket {
    int64_t unix_us;
};

struct __attribute__((packed)) dataTx {
    int64_t esp_elapsed_us;   // starts at 0
    int64_t pc_us;            // synced once, then increments
    uint32_t utc_date;
    uint32_t utc_time;
    float acc[3];
    float gyro[3];
    float mag[3];
    float temp;
    float roll, pitch, yaw;
    double lat;
    double lng;
    float speed_kmph;
    float alt_meters;
    uint32_t satellites;
    uint32_t hdop_value;
    float heading_deg;
};

volatile dataTx ring[BUFFER_SIZE];
volatile uint16_t writeIndex = 0;
volatile uint16_t sdReadIndex = 0;
volatile uint16_t espNowReadIndex = 0;
char csvBuffer[SD_WRITE_BATCH*360];

// ================= TIME HANDLING =================
int64_t pc_start_us = 0;
int64_t esp_start_us = 0;
int64_t first_pc_stamp = 0;
volatile bool first_sample = true;

// ================= ESP-NOW CALLBACKS =================

void OnTimeSyncRecv(const esp_now_recv_info_t * info, const uint8_t *incomingData, int len) {
    if (len != sizeof(TimeSyncPacket)) return;

    TimeSyncPacket receivedSync;
    memcpy(&receivedSync, incomingData, sizeof(TimeSyncPacket));

    int64_t current_esp_time = esp_timer_get_time();

    pc_start_us = receivedSync.unix_us;
    first_pc_stamp = current_esp_time;
    Serial.printf("PC time synced: %lld\n", pc_start_us);
}

// ================= SD FILE =================
char DATA_FILE_PATH[64];
bool createSequentialFile() {
    int fileIndex = 1;
    while (fileIndex <= 9999) {
        snprintf(DATA_FILE_PATH, sizeof(DATA_FILE_PATH), "/data_%04d.csv", fileIndex);
        if (!SD.exists(DATA_FILE_PATH)) {
            dataFile = SD.open(DATA_FILE_PATH, FILE_WRITE);
            if (!dataFile) return false;
            // NOTE: HDOP is scaled by 100 in the CSV printout (%.2f) but is stored as an integer here.
            dataFile.println("ESP_elapsed_us,PC_time_us,UTC_Date,UTC_Time,AccX,AccY,AccZ,GyroX,GyroY,GyroZ,MagX,MagY,MagZ,Temp,Roll,Pitch,Yaw,Lat,Lng,Speed_kmph,Alt_meters,Satellites,HDOP,Heading_deg");
            dataFile.flush();
            Serial.printf("SD initialized, writing to file: %s\n", DATA_FILE_PATH);
            return true;
        }
        fileIndex++;
    }
    return false;
}

// ================= TIMER CALLBACK (ISR) =================
void IRAM_ATTR samplingCallback(void* arg) {
    int idx = writeIndex;
    int64_t current_esp_time = esp_timer_get_time();

    if (first_sample) {
        esp_start_us = current_esp_time;
        first_sample = false;
    }

    // 1. TIMING
    ring[idx].esp_elapsed_us = current_esp_time - esp_start_us;
    
    if(first_pc_stamp)
      ring[idx].pc_us = current_esp_time - first_pc_stamp + pc_start_us;
    else
      ring[idx].pc_us = 0;
      
    // 2. GPS DATA (Read from protected variable)
    portENTER_CRITICAL_ISR(&gpsDataMux);
    ring[idx].utc_date = currentGpsData.date_value;
    ring[idx].utc_time = currentGpsData.time_value;
    ring[idx].lat = currentGpsData.lat;
    ring[idx].lng = currentGpsData.lng;
    ring[idx].speed_kmph = currentGpsData.speed_kmph;
    ring[idx].alt_meters = currentGpsData.alt_meters;
    ring[idx].satellites = currentGpsData.satellites;
    ring[idx].hdop_value = currentGpsData.hdop_value;
    ring[idx].heading_deg = currentGpsData.heading_deg;
    portEXIT_CRITICAL_ISR(&gpsDataMux);

    // 3. IMU READING
    xyzFloat acc = mpu.getGValues();
    xyzFloat gyr = mpu.getGyrValues();
    xyzFloat mag = mpu.getMagValues();
    ring[idx].temp = mpu.getTemperature();

    //update max values
    if(acc.x>MaxX)
      MaxX = acc.x;
    if(acc.y>MaxY)
      MaxY = acc.y;
    if(acc.z>MaxZ)
      MaxZ = acc.z;

      
    ring[idx].acc[0]=acc.x; ring[idx].acc[1]=acc.y; ring[idx].acc[2]=acc.z;
    ring[idx].gyro[0]=gyr.x; ring[idx].gyro[1]=gyr.y; ring[idx].gyro[2]=gyr.z;
    ring[idx].mag[0]=mag.x; ring[idx].mag[1]=mag.y; ring[idx].mag[2]=mag.z;

    // 4. AHRS FILTER
    filter.update(gyr.x*DEG_TO_RAD,gyr.y*DEG_TO_RAD,gyr.z*DEG_TO_RAD,
                  acc.x,acc.y,acc.z,
                  mag.x,mag.y,mag.z);
    ring[idx].roll = filter.getRoll();
    ring[idx].pitch = filter.getPitch();
    ring[idx].yaw = filter.getYaw();

    // 5. ADVANCE INDEX
    writeIndex = (writeIndex+1) % BUFFER_SIZE;
}

// ================= GPS TASK =================
void gpsTask(void* parameter) {
    for (;;) {
        // Read all available GPS data
        while(gpsSerial.available()>0){
            if(gps.encode(gpsSerial.read())){
                
                // Only update the shared variable if new location/data is available
                if(gps.location.isUpdated() || gps.altitude.isUpdated() || gps.satellites.isUpdated() || gps.date.isUpdated()){
                    
                    portENTER_CRITICAL(&gpsDataMux);
                    
                    currentGpsData.lat = gps.location.lat();
                    currentGpsData.lng = gps.location.lng();
                    currentGpsData.speed_kmph = gps.speed.kmph();
                    currentGpsData.alt_meters = gps.altitude.meters();
                    currentGpsData.satellites = gps.satellites.value();
                    currentGpsData.hdop_value = gps.hdop.value(); // TinyGPS++ HDOP is x100
                    currentGpsData.heading_deg = gps.course.deg();

                    if (gps.date.isValid() && gps.time.isValid()) {
                        currentGpsData.date_value = gps.date.value();
                        currentGpsData.time_value = gps.time.value();
                    } else {
                        currentGpsData.date_value = 0;
                        currentGpsData.time_value = 0;
                    }
                    portEXIT_CRITICAL(&gpsDataMux);
                }
            }
        }
        //check if gps data is valid
        if(currentGpsData.hdop_value>10)
          GPSValid = false;
        else
          GPSValid = true;
        // Small delay to yield to other tasks
        vTaskDelay(pdMS_TO_TICKS(1)); 
        //update lcd display
    
        dataTx s;
        uint16_t currentSampleIndex = (writeIndex + BUFFER_SIZE - 1) % BUFFER_SIZE;
        // FIX: Use taskENTER/EXIT_CRITICAL with the specific ringBufferMux.
        taskENTER_CRITICAL(&ringBufferMux);
        memcpy(&s, (const void*)&ring[currentSampleIndex], sizeof(dataTx));
        taskEXIT_CRITICAL(&ringBufferMux);
        lcd.printf("X%0.1f Y%0.1f Z%0.1f",MaxX,MaxY,MaxZ);
        lcd.locate(2,1);
        lcd.printf("R%dG%d X%d Y%d Z%d",REC,GPSValid,int(abs(s.acc[0])),int(abs(s.acc[1])),int(abs(s.acc[2])));
        lcd.home();
    }
    
}

// ================= SD WRITER TASK =================
void writeBatchToSD() {
    if(!dataFile) return;

    uint16_t localRead = sdReadIndex;
    uint16_t localWrite = writeIndex;
    char* ptr = csvBuffer;
    int lenTotal = 0;
    int batchCount = 0;

    while(localRead != localWrite && batchCount < SD_WRITE_BATCH) {
        dataTx s;
        
        // FIX: Use taskENTER/EXIT_CRITICAL with the specific ringBufferMux.
        // This makes copying the dataTx atomic relative to the ISR that writes to the ring.
        taskENTER_CRITICAL(&ringBufferMux);
        memcpy(&s, (const void*)&ring[localRead], sizeof(dataTx));
        taskEXIT_CRITICAL(&ringBufferMux);

        // NOTE: HDOP is stored as an integer (x100) and divided by 100.0 here for the CSV output (%.2f).
        int len = snprintf(ptr, sizeof(csvBuffer)-lenTotal,
            "%lld,%lld,%u,%u,%.2f,%.2f,%.2f,%.2f,%.2f,%.2f,%.2f,%.2f,%.2f,%.2f,%.2f,%.2f,%.2f,%.6f,%.6f,%.2f,%.2f,%u,%.2f,%.2f\n",
            s.esp_elapsed_us, s.pc_us, s.utc_date, s.utc_time,
            s.acc[0],s.acc[1],s.acc[2],
            s.gyro[0],s.gyro[1],s.gyro[2],
            s.mag[0],s.mag[1],s.mag[2],
            s.temp,
            s.roll, s.pitch, s.yaw,
            s.lat, s.lng, s.speed_kmph, s.alt_meters,
            s.satellites, (float)s.hdop_value/100.0, s.heading_deg);

        if(len <= 0 || lenTotal + len >= sizeof(csvBuffer)) break;

        ptr += len;
        lenTotal += len;
        localRead = (localRead + 1) % BUFFER_SIZE;
        batchCount++;
       
    }

    if(lenTotal > 0){
        dataFile.write((const uint8_t*)csvBuffer, lenTotal);
        dataFile.flush();
        sdReadIndex = localRead;
    }
    //Check if file size grew
    if (filesize<dataFile.size())
        REC = true;
    else
        REC = false;
    filesize = dataFile.size();
}

// ================= ESP-NOW SEND =================
void sendCurrentSample() {
    // Get the index of the most recently written sample
    uint16_t currentSampleIndex = (writeIndex + BUFFER_SIZE - 1) % BUFFER_SIZE;
    
    // Check if the sample has already been sent (simple rate-limiting check)
    if (currentSampleIndex == espNowReadIndex) return;

    dataTx s;
    
    // FIX: Use taskENTER/EXIT_CRITICAL with the specific ringBufferMux.
    taskENTER_CRITICAL(&ringBufferMux);
    memcpy(&s, (const void*)&ring[currentSampleIndex], sizeof(dataTx));
    taskEXIT_CRITICAL(&ringBufferMux);

    
    
    
    // Send the data
    esp_now_send(rx_peer_mac, (uint8_t*)&s, sizeof(s));
    
    // Update the read index to the sample that was just sent
    espNowReadIndex = currentSampleIndex;

    
}

// ================= SETUP =================
void setup(){
    Serial.begin(115200);
    delay(500);
    Serial.println("Starting TX with MPU and GPS...");

    lcd.begin(LCD_ROWS, LCD_COLUMNS);
    lcd.cls();
    lcd.display(BACKLIGHT_ON);
    lcd.home();
    

    // 1. IMU SETUP
    hspi.begin(HSPI_SCLK, HSPI_MISO, HSPI_MOSI, HSPI_CS);
    if(!mpu.init()) {
        Serial.println("MPU Init Failed!");
        while(1);
    }
    mpu.initMagnetometer();
    mpu.setSampleRateDivider(0);
    mpu.enableGyrDLPF();
    mpu.setGyrDLPF(MPU9250_DLPF_6);
    mpu.setGyrRange(MPU9250_GYRO_RANGE_2000);
    mpu.setAccRange(MPU9250_ACC_RANGE_16G);
    mpu.enableAccDLPF(false);

    mpu.autoOffsets();

    // 2. SD SETUP
    sdSPI.begin();
    if(!SD.begin(SD_CS_PIN,sdSPI) || !createSequentialFile()){
        Serial.println("SD init failed! Running without SD.");
    }

    // 3. GPS TASK
    gpsSerial.begin(GPS_BAUD,SERIAL_8N1,RXD2,TXD2);
    // Pin GPS task to Core 1, priority 1
    xTaskCreatePinnedToCore(gpsTask,"GpsTask",4096,NULL,1,NULL,1); 

    // 4. ESP-NOW SETUP
    WiFi.mode(WIFI_STA);
    esp_now_init();
    esp_now_register_recv_cb(OnTimeSyncRecv);
    
    esp_now_peer_info_t peerInfo={};
    memcpy(peerInfo.peer_addr,rx_peer_mac,6);
    peerInfo.channel=1;
    peerInfo.encrypt=false;
    esp_now_add_peer(&peerInfo);

    // 5. SAMPLING TIMER
    const esp_timer_create_args_t timer_args={
        .callback=&samplingCallback,
        .arg=NULL,
        .dispatch_method=ESP_TIMER_TASK,
        .name="mpu_sampling"
    };
    esp_timer_handle_t timer;
    esp_timer_create(&timer_args,&timer);
    // Start at the desired rate
    esp_timer_start_periodic(timer, 1000000/SAMPLE_RATE_HZ); 

    Serial.printf("Sampling timer at %d Hz.\n", SAMPLE_RATE_HZ);
}

// ================= LOOP =================
void loop(){
    static unsigned long lastSend=0;
    unsigned long now=millis();
    
    // ESP-NOW transmission loop
    if(now-lastSend>=1000/ESPNOW_RATE_HZ){
        lastSend=now;
        sendCurrentSample();
    }

    // SD card writing loop
    writeBatchToSD();

    delay(1); // Small delay to allow scheduler to run other tasks/IDLE
}