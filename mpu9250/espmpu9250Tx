#include <SPI.h>
#include <SD.h>
#include <MPU9250_WE.h>
#include <WiFi.h>
#include <esp_now.h>
#include <esp_timer.h>
#include "MadgwickAHRS.h"

// ================= SETTINGS =================
#define SAMPLE_RATE_HZ      4000      // MPU sample rate
#define ESPNOW_RATE_HZ      250       // ESP-NOW send rate
#define BUFFER_SIZE         512
#define SD_WRITE_BATCH      16
#define HSPI_MISO           26
#define HSPI_MOSI           27
#define HSPI_SCLK           25
#define HSPI_CS             14
#define SD_CS_PIN           5

// ================= OBJECTS =================
SPIClass hspi(HSPI);
SPIClass sdSPI(VSPI);
MPU9250_WE mpu(&hspi, HSPI_CS, true);
Madgwick filter;
File dataFile;

// ================= DATA STRUCTURE =================
struct __attribute__((packed)) dataTx {
  int64_t t_us;
  float acc[3];
  float gyro[3];
  float mag[3];
  float temp;
  float roll, pitch, yaw;
};

volatile dataTx ring[BUFFER_SIZE];
volatile uint16_t writeIndex = 0;
volatile uint16_t sdReadIndex = 0;
volatile uint16_t espNowReadIndex = 0;

// ================= ESP-NOW =================
uint8_t broadcastAddress[] = {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF};

// ================= SD FILE =================
char DATA_FILE_PATH[32];
bool createSequentialFile() {
  int fileIndex = 1;
  while (fileIndex <= 9999) {
    snprintf(DATA_FILE_PATH, sizeof(DATA_FILE_PATH), "/data_%04d.csv", fileIndex);
    if (!SD.exists(DATA_FILE_PATH)) {
      dataFile = SD.open(DATA_FILE_PATH, FILE_WRITE);
      if (!dataFile) return false;
      dataFile.println("t_us,AccX,AccY,AccZ,GyroX,GyroY,GyroZ,MagX,MagY,MagZ,Temp,Roll,Pitch,Yaw");
      dataFile.flush();
      Serial.printf("SD initialized, writing to file: %s\n", DATA_FILE_PATH);
      return true;
    }
    fileIndex++;
  }
  return false;
}

// ================= TIMER CALLBACK =================
void IRAM_ATTR samplingCallback(void* arg) {
  int idx = writeIndex;

  // Timestamp
  ring[idx].t_us = esp_timer_get_time();

  // Read MPU9250
  xyzFloat acc = mpu.getGValues();
  xyzFloat gyr = mpu.getGyrValues();
  xyzFloat mag = mpu.getMagValues();
  float temp = mpu.getTemperature();

  ring[idx].acc[0] = acc.x; ring[idx].acc[1] = acc.y; ring[idx].acc[2] = acc.z;
  ring[idx].gyro[0] = gyr.x; ring[idx].gyro[1] = gyr.y; ring[idx].gyro[2] = gyr.z;
  ring[idx].mag[0] = mag.x; ring[idx].mag[1] = mag.y; ring[idx].mag[2] = mag.z;
  ring[idx].temp = temp;

  // Madgwick filter update
  filter.update(gyr.x * DEG_TO_RAD, gyr.y * DEG_TO_RAD, gyr.z * DEG_TO_RAD,
                acc.x, acc.y, acc.z,
                mag.x, mag.y, mag.z);

  ring[idx].roll  = filter.getRoll();
  ring[idx].pitch = filter.getPitch();
  ring[idx].yaw   = filter.getYaw();

  writeIndex = (writeIndex + 1) % BUFFER_SIZE;
}

// ================= SD WRITER =================
void writeBatchToSD() {
  if (!dataFile) return;

  uint16_t localRead = sdReadIndex;
  uint16_t localWrite = writeIndex;
  char csvBuffer[SD_WRITE_BATCH * 200];
  char* ptr = csvBuffer;
  int lenTotal = 0;
  int batchCount = 0;

  while (localRead != localWrite && batchCount < SD_WRITE_BATCH) {
    // safe copy from volatile
    dataTx s = *(dataTx*)&ring[localRead];

    int len = snprintf(ptr, sizeof(csvBuffer) - lenTotal,
                       "%lld,%.6f,%.6f,%.6f,%.6f,%.6f,%.6f,%.6f,%.6f,%.6f,%.2f,%.2f,%.2f,%.2f\n",
                       s.t_us,
                       s.acc[0], s.acc[1], s.acc[2],
                       s.gyro[0], s.gyro[1], s.gyro[2],
                       s.mag[0], s.mag[1], s.mag[2],
                       s.temp,
                       s.roll, s.pitch, s.yaw);
    if (len <= 0 || lenTotal + len >= sizeof(csvBuffer)) break;
    ptr += len;
    lenTotal += len;

    localRead = (localRead + 1) % BUFFER_SIZE;
    batchCount++;
  }

  if (lenTotal > 0) {
    dataFile.write((const uint8_t*)csvBuffer, lenTotal);
    dataFile.flush();
    sdReadIndex = localRead;
  }
}

// ================= ESP-NOW SEND =================
void sendBatch() {
  uint16_t localRead = espNowReadIndex;
  uint16_t localWrite = writeIndex;

  while (localRead != localWrite) {
    // safe copy from volatile
    dataTx s = *(dataTx*)&ring[localRead];

    // send one struct at a time
    esp_now_send(broadcastAddress, (uint8_t*)&s, sizeof(s));

    localRead = (localRead + 1) % BUFFER_SIZE;
  }

  espNowReadIndex = localRead;
}

// ================= SETUP =================
void setup() {
  Serial.begin(115200);
  delay(500);
  Serial.println("Starting TX...");

  // MPU init
  hspi.begin(HSPI_SCLK, HSPI_MISO, HSPI_MOSI, HSPI_CS);
  if (!mpu.init()) while (1);
  mpu.initMagnetometer();
  mpu.setSampleRateDivider(0);
  mpu.enableGyrDLPF();
  mpu.setGyrDLPF(MPU9250_DLPF_6);
  mpu.setGyrRange(MPU9250_GYRO_RANGE_2000);
  mpu.setAccRange(MPU9250_ACC_RANGE_16G);
  mpu.enableAccDLPF(false);

  Serial.println("Calibrating gyro...");
  mpu.autoOffsets();
  Serial.println("Calibration done.");

  // SD init
  sdSPI.begin();
  if (!SD.begin(SD_CS_PIN, sdSPI) || !createSequentialFile()) {
    Serial.println("SD init failed!");
  }

  // ESP-NOW init
  WiFi.mode(WIFI_STA);
  if (esp_now_init() != ESP_OK) Serial.println("ESP-NOW init failed");

  esp_now_peer_info_t peerInfo = {};
  memcpy(peerInfo.peer_addr, broadcastAddress, 6);
  peerInfo.channel = 1;
  peerInfo.encrypt = false;
  esp_now_add_peer(&peerInfo);

  // Timer setup for 4 kHz sampling
  const esp_timer_create_args_t timer_args = {
    .callback = &samplingCallback,
    .arg = NULL,
    .dispatch_method = ESP_TIMER_TASK,
    .name = "mpu_sampling"
  };

  esp_timer_handle_t timer;
  esp_timer_create(&timer_args, &timer);
  esp_timer_start_periodic(timer, 1000000 / SAMPLE_RATE_HZ);
}

// ================= LOOP =================
void loop() {
  static unsigned long lastSend = 0;
  unsigned long now = millis();

  // ESP-NOW send at 250 Hz
  if (now - lastSend >= 1000 / ESPNOW_RATE_HZ) {
    lastSend = now;
    sendBatch();
  }

  // SD write
  writeBatchToSD();

  delay(1); // small yield
}
